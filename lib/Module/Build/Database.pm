package Module::Build::Database;

=head1 NAME

Module::Build::Database - Manage database patches in the style of Module::Build.

=head1 SYNOPSIS

 # In Build.PL :

 use Module::Build::Database;

 my $builder = Module::Build::Database->new(
    database_type => "PostgreSQL",
    ...other module build options..
  );

 # Put database patches into db/patches/*.sql.
 # A schema will be autogenerated in db/dist/all.sql.
 # Documentation will be autogenerated in db/doc/.

 # That is, first do this :
 perl Build.PL

 # Then, test that patches in db/patches/ will apply successfully to
 # the schema in db/dist/ :
 ./Build dbtest

 # The, update the db information in db/dist/ by applying any
 # unapplied patches in db/patches/ to the schema in db/dist/ :
 ./Build dbdist

 # Update the docs in db/docs using the schema in db/dist :
 ./Build dbdocs

 # Install a new database or upgrade an existing one :
 ./Build dbfakeinstall
 ./Build dbinstall

Additionally, when doing

 ./Build install

The db/ directory will be installed into <install root>/etc/Module-Name/db.

=head1 DESCRIPTION

This is a subclass of Module::Build for modules which depend on a database,
which adds functionality for testing and distributing changes to the database.

Changes are represented as sql files ("patches") which will be fed into a
command line client for the database.

A complete schema is regenerated whenever "dbdist" is run.

A list of the patches which have been applied is stored in two places :
    (1) the file "db/dist/patches_applied.txt"
    (2) the table "patches_applied" within the target database.

When the dbinstall action is invoked, any patches in (1) but
not in (2) are applied.  In order to determine whether they will apply
successfully, "dbfakeinstall" may be run, which does the following :

    1. Dumps the schema for an existing instance.
    2. Applies any patches not found in the "patches_applied" table.
    3. Dumps the resulting schema and compares it to the schema in db/dist/all.sql.

If the comparison in step 3 is the same, then one may conclude that applying
the missing patches will produce the desired schema.

The actions added by this subclass are as follows :

=over

=item dbdist

This creates the file db/dist/all.sql.

It does this by reading patches from db/patches/*.sql,
applying the ones that are not listed in db/dist/patches_applied.txt,
and then dumping out a new db/dist/all.sql.

In other words :

 1. Start a new empty database instance.
 2. Populate the schema using db/dist/all.sql.
 3. For every patch in db/patches/*.sql :
    Is the patch is listed in db/dist/patches_applied.txt?
    Yes?  Skip it.
    No?  Apply it, and add it to db/dist/patches_applied.txt.
 4. Dump the new schema out to db/dist/all.sql
 5. Stop the database.

=item dbtest

 1. Start a new empty database instance.
 2. Apply db/dist/all.sql.
 3. Apply any patches in db/patches/*.sql that are
    not in db/dist/patches_applied.txt.
    For each of the above, the tests will fail if any of the
    patches do not apply cleanly.
 4. Shut down the database instance.

=item dbdocs

 1. Start a new empty database instance.
 2. Apply db/dist/all.sql.
 3. Dump the new schema docs out to db/doc.
 4. Stop the database.

=item dbfakeinstall

 1. Look for a running database, based on environment variables.
 2. Display the connection information obtained from the above.
 3. Dump the schema from the live database to a temporary directory.
 4. Apply patches listed in db/dist/patches_applied.txt that are not
    in the patches_applied table.
 5. Dump out the resulting schema, and compare it to db/dist/all.sql.

=item dbinstall

 1. Look for a running database, based on environment variables
 2. Apply any patches in db/patches/ that are not in the patches_applied table.
 3. Add an entry to the patches_applied table for each patch applied.

=back

=head1 NOTES

If A database needs to be brought up to date post facto the command line tool
"mbd-tool" may be used to perform the fakeinstall and install actions.

Patches will be applied in lexicographic order, so their names should start
with a sequence of digits, e.g.  0010_something.sql, 0020_something_else.sql, etc.

=head1 SEE ALSO

mbd-tool -- a command line tool for locating and installing database patches
which are associated with Perl modules.

=cut

use warnings;
use strict;
use base 'Module::Build';

our $VERSION = 0.01;

sub new {
    my $class = shift;
    my %args = @_;
    # recursive constructor, fun
    my $driver = delete $args{database_type}
      or return $class->SUPER::new(%args);
    my $subclass = "$class\::$driver";
    eval "use $subclass";
    die $@ if $@;
    return $subclass->new(%args);
}

sub ACTION_dbtest {
    my $self = shift;
    $self->_make_new_db();
}

sub ACTION_dbdist {
    my $self = shift;

}

sub ACTION_dbdocs {
    my $self = shift;

}

sub ACTION_dbinstall {
    my $self = shift;

}

sub ACTION_dbfakeinstall {
    my $self = shift;

}

1;

